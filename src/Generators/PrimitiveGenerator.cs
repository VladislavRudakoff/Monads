namespace Generators;

[Generator]
public sealed class PrimitiveGenerator
{
    private const string RootPrimitiveAttributeShortName = "RootPrimitive";
    private const string RootPrimitiveAttributeFullName = RootPrimitiveAttributeShortName + "Attribute";
    private const string RootPrimitiveAttributeTypeName = "System." + RootPrimitiveAttributeFullName;

    private const string PrimitiveAttributeShortName = "Primitive";
    private const string PrimitiveAttributeFullName = PrimitiveAttributeShortName + "Attribute"; 
    private const string PrimitiveAttributeTypeName = "System." + PrimitiveAttributeFullName;

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        if (!Debugger.IsAttached)
        {
            Debugger.Launch();
        }

        IncrementalValueProvider<ImmutableArray<ITypeSymbol?>> types = context.SyntaxProvider
            .CreateSyntaxProvider(CouldBePrimitiveAsync, GetTypeOrNull)
            .Where(t => t is not null)
            .Collect();

        context.RegisterSourceOutput(types, GenerateCode!);
    }

    private static bool CouldBePrimitiveAsync(
        SyntaxNode syntaxNode,
        CancellationToken cancellationToken = default)
    {
        if (syntaxNode is not AttributeSyntax attribute)
        {
            return false;
        }

        string? name = ExtractName(attribute.Name);

        return name is PrimitiveAttributeShortName or PrimitiveAttributeFullName;
    }

    private static string? ExtractName(NameSyntax? name) =>
        name switch
        {
            SimpleNameSyntax ins => ins.Identifier.Text,
            QualifiedNameSyntax qns => qns.Right.Identifier.Text,
            _ => null
        };

    private static ITypeSymbol? GetTypeOrNull(
        GeneratorSyntaxContext context,
        CancellationToken cancellationToken)
    {
        AttributeSyntax attributeSyntax = (AttributeSyntax)context.Node;

        if (attributeSyntax.Parent?.Parent is not ClassDeclarationSyntax classDeclaration)
            return null;

        return context.SemanticModel.GetDeclaredSymbol(classDeclaration) is not ITypeSymbol type || !IsPrimitive(type) ? null : type;
    }

    private static bool IsPrimitive(ISymbol type)
    {
        ImmutableArray<AttributeData> attributes = type.GetAttributes();

        bool result = attributes
            .Any(a => a.AttributeClass is 
            {
                Name: PrimitiveAttributeFullName,
                ContainingNamespace: 
                {
                    Name: "Attributes",
                    ContainingNamespace.IsGlobalNamespace: false
                }
            });
            
        return result;
    }

    private static void GenerateCode(
        SourceProductionContext context,
        ImmutableArray<ITypeSymbol> enumerations)
    {
        if (enumerations.IsDefaultOrEmpty)
            return;

        foreach (var type in enumerations)
        {
            var code = GenerateCode(type);
            var typeNamespace = type.ContainingNamespace.IsGlobalNamespace
                ? null
                : $"{type.ContainingNamespace}.";

            context.AddSource($"{typeNamespace}{type.Name}.g.cs", code);
        }
    }

    private static string GenerateCode(ITypeSymbol type)
    {
        string? ns = type.ContainingNamespace.IsGlobalNamespace
            ? null
            : type.ContainingNamespace.ToString();
        string name = type.Name;
        IEnumerable<string?> items = GetItemNames(type);

        return @$"// <auto-generated />

using System.Collections.Generic;

{(ns is null ? null : $@"namespace {ns}
{{")}
   partial class {name}
   {{
      private static IReadOnlyList<{name}> _items;
      public static IReadOnlyList<{name}> Items => _items ??= GetItems();

      private static IReadOnlyList<{name}> GetItems()
      {{
         return new[] {{ {String.Join(", ", items)} }};
      }}
   }}
{(ns is null ? null : @"}
")}";
    }

    private static IEnumerable<string?> GetItemNames(ITypeSymbol type) =>
        type.GetMembers()
            .Select(m =>
            {
                if (!m.IsStatic ||
                    m.DeclaredAccessibility != Accessibility.Public ||
                    m is not IFieldSymbol field)
                    return null;

                return SymbolEqualityComparer.Default.Equals(field.Type, type)
                    ? field.Name
                    : null;
            })
            .Where(field => field is not null);
}