namespace Generators;

[Generator]
public sealed class PrimitiveGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext generatorContext)
    {
        if (!Debugger.IsAttached)
        {
            Debugger.Launch();
        }

        generatorContext.RegisterPostInitializationOutput(t =>
            t.AddSource("PrimitiveAttribute.g.cs", SourceText.From(Attributes.AttributesDeclaration, Encoding.UTF8)));

        PrimitiveComparer comparer = PrimitiveComparer.Instance;

        IncrementalValuesProvider<PrimitiveToGenerate> pipeline = generatorContext.SyntaxProvider
            .CreateSyntaxProvider(
                FilterSyntaxNodes.NodePredicate,
                FilterSyntaxNodes.TargetFactory)
            .Where(t => t is not null)!
            .WithComparer(comparer)
            .Collect()
            .SelectMany((targets, _) => targets.Distinct(comparer));

        generatorContext.RegisterSourceOutput(pipeline, Execute);
    }

    private static void Execute(
        SourceProductionContext context,
        PrimitiveToGenerate primitive)
    {
        string? typeNamespace = primitive.Type.ContainingNamespace.IsGlobalNamespace
            ? null
            : primitive.Type.ContainingNamespace.ToString();

        string code = GenerateCode(primitive, typeNamespace);

        context.AddSource($"{primitive.Type.Name}.g", code);
    }

    private static string GenerateCode(PrimitiveToGenerate primitiveModel, string? typeNamespace)
    {
        string modifiers = string.Join(" ", primitiveModel.Declaration.Modifiers);

        string primitiveModelTypeName = primitiveModel.Type.Name;

        return primitiveModel.ModelType switch
        {
            SyntaxKind.ClassDeclaration => GenerateClass(
                typeNamespace,
                modifiers,
                primitiveModel.AttributePrimitiveName,
                primitiveModel.Declaration.Keyword.Text,
                primitiveModelTypeName),
            SyntaxKind.RecordDeclaration => GenerateRecord(
                typeNamespace,
                modifiers,
                primitiveModel.AttributePrimitiveName,
                primitiveModel.Declaration.Keyword.Text,
                primitiveModelTypeName),
            SyntaxKind.RecordStructDeclaration => GenerateRecordStruct(
                typeNamespace,
                modifiers,
                primitiveModel.AttributePrimitiveName,
                primitiveModel.Declaration.Keyword.Text,
                primitiveModelTypeName),
            _ => GenerateStruct(
                typeNamespace,
                modifiers,
                primitiveModel.AttributePrimitiveName,
                primitiveModel.Declaration.Keyword.Text,
                primitiveModelTypeName)
        };
    }

    private static string GenerateRecordStruct(
        string? typeNamespace,
        string modifiers,
        string primitiveType,
        string keyword,
        string typeName) =>
        @$"// <auto-generated />
{(typeNamespace is null ? null : $@"namespace {typeNamespace}
{{")}
   /// <summary>
   /// Custom primitive.
   /// </summary>
   {modifiers} {keyword} struct {typeName}
   {{
        /// <summary>
        /// Primitive value.
        /// </summary>
        public {primitiveType} Value {{ get; }}

        /// <summary>
        /// Private ctor.
        /// </summary>
        /// <param name=""value"">Built-in language primitive value.</param>
        private {typeName}({primitiveType} value) => Value = value;

        /// <summary>
        /// Leads from object <see cref=""{primitiveType}""/> to object <see cref=""{typeName}""/>. 
        /// </summary>
        /// <param name=""primitive"">Built-in language primitive value.</param>
        public static explicit operator {typeName}({primitiveType} primitive) => new(primitive);

        /// <summary>
        /// Leads from object <see cref=""{typeName}""/> to object <see cref=""{primitiveType}""/>.
        /// </summary>
        /// <param name=""customPrimitive"">Custom primitive value.</param>
        public static implicit operator {primitiveType}({typeName} customPrimitive) => customPrimitive.Value;

        /// <inheritdoc />
        public override string ToString() => Value.ToString();

        /// <summary>
        /// Create new instance.
        /// </summary>
        /// <param name=""primitive"">Built-in language primitive value.</param>
        /// <returns>Custom primitive.</returns>
        public static {typeName} New({primitiveType} primitive) => new(primitive);
   }}
{(typeNamespace is null ? null : @"}
")}";

    private static string GenerateStruct(
        string? typeNamespace,
        string modifiers,
        string primitiveType,
        string keyword,
        string typeName) =>
        @$"// <auto-generated />
{(typeNamespace is null ? null : $@"namespace {typeNamespace}
{{")}
   /// <summary>
   /// Custom primitive.
   /// </summary>
   {modifiers} {keyword} {typeName} : System.IEquatable<{typeName}>
   {{
        /// <summary>
        /// Primitive value.
        /// </summary>
        public {primitiveType} Value {{ get; }}

        /// <summary>
        /// Private ctor.
        /// </summary>
        /// <param name=""value"">Built-in language primitive value.</param>
        private {typeName}({primitiveType} value) => Value = value;

        /// <summary>
        /// Leads from object <see cref=""{primitiveType}""/> to object <see cref=""{typeName}""/>. 
        /// </summary>
        /// <param name=""primitive"">Built-in language primitive value.</param>
        public static explicit operator {typeName}({primitiveType} primitive) => new(primitive);

        /// <summary>
        /// Leads from object <see cref=""{typeName}""/> to object <see cref=""{primitiveType}""/>.
        /// </summary>
        /// <param name=""customPrimitive"">Custom primitive value.</param>
        public static implicit operator {primitiveType}({typeName} customPrimitive) => customPrimitive.Value;

        public static bool operator ==({typeName} lhs, {typeName} rhs) => lhs.Equals(rhs);

        public static bool operator !=({typeName} lhs, {typeName} rhs) => !(lhs == rhs);

        /// <inheritdoc />
        public override string ToString() => Value.ToString();

        /// <summary>
        /// Create new instance.
        /// </summary>
        /// <param name=""primitive"">Built-in language primitive value.</param>
        /// <returns>Custom primitive.</returns>
        public static {typeName} New({primitiveType} primitive) => new(primitive);

        /// <inheritdoc />
        public bool Equals({typeName} other) => Value == other.Value;

        /// <inheritdoc />
        public override bool Equals(object obj)
        {{
            if (obj is null)
            {{
                return false;
            }}

            if (ReferenceEquals(this, obj))
            {{
                return true;
            }}

            return obj.GetType() == GetType()
                   && Equals(({typeName})obj);
        }}

        /// <inheritdoc />
        public override int GetHashCode() => Value.GetHashCode();
   }}
{(typeNamespace is null ? null : @"}
")}";

    private static string GenerateClass(
        string? typeNamespace,
        string modifiers,
        string primitiveType,
        string keyword,
        string typeName) =>
        @$"// <auto-generated />
{(typeNamespace is null ? null : $@"namespace {typeNamespace}
{{")}
   /// <summary>
   /// Custom primitive.
   /// </summary>
   {modifiers} {keyword} {typeName} : System.IEquatable<{typeName}>
   {{
        /// <summary>
        /// Primitive value.
        /// </summary>
        public {primitiveType} Value {{ get; }}

        /// <summary>
        /// Private ctor.
        /// </summary>
        /// <param name=""value"">Built-in language primitive value.</param>
        private {typeName}({primitiveType} value) => Value = value;

        /// <summary>
        /// Leads from object <see cref=""{primitiveType}""/> to object <see cref=""{typeName}""/>. 
        /// </summary>
        /// <param name=""primitive"">Built-in language primitive value.</param>
        public static explicit operator {typeName}({primitiveType} primitive) => new(primitive);

        /// <summary>
        /// Leads from object <see cref=""{typeName}""/> to object <see cref=""{primitiveType}""/>.
        /// </summary>
        /// <param name=""customPrimitive"">Custom primitive value.</param>
        public static implicit operator {primitiveType}({typeName} customPrimitive) => customPrimitive.Value;

        public static bool operator ==({typeName} lhs, {typeName} rhs) => lhs.Equals(rhs);

        public static bool operator !=({typeName} lhs, {typeName} rhs) => !(lhs == rhs);

        /// <inheritdoc />
        public override string ToString() => Value.ToString();

        /// <summary>
        /// Create new instance.
        /// </summary>
        /// <param name=""primitive"">Built-in language primitive value.</param>
        /// <returns>Custom primitive.</returns>
        public static {typeName} New({primitiveType} primitive) => new(primitive);

        /// <inheritdoc />
        public bool Equals({typeName} other) => Value == other.Value;

        /// <inheritdoc />
        public override bool Equals(object obj)
        {{
            if (obj is null)
            {{
                return false;
            }}

            if (ReferenceEquals(this, obj))
            {{
                return true;
            }}

            return obj.GetType() == GetType()
                   && Equals(({typeName})obj);
        }}

        /// <inheritdoc />
        public override int GetHashCode() => Value.GetHashCode();
   }}
{(typeNamespace is null ? null : @"}
")}";

    private static string GenerateRecord(
        string? typeNamespace,
        string modifiers,
        string primitiveType,
        string keyword,
        string typeName) =>
        @$"// <auto-generated />
{(typeNamespace is null ? null : $@"namespace {typeNamespace}
{{")}
   /// <summary>
   /// Custom primitive.
   /// </summary>
   {modifiers} {keyword} {typeName}
   {{
        /// <summary>
        /// Primitive value.
        /// </summary>
        public {primitiveType} Value {{ get; }}

        /// <summary>
        /// Private ctor.
        /// </summary>
        /// <param name=""value"">Built-in language primitive value.</param>
        private {typeName}({primitiveType} value) => Value = value;

        /// <summary>
        /// Leads from object <see cref=""{primitiveType}""/> to object <see cref=""{typeName}""/>. 
        /// </summary>
        /// <param name=""primitive"">Built-in language primitive value.</param>
        public static explicit operator {typeName}({primitiveType} primitive) => new(primitive);

        /// <summary>
        /// Leads from object <see cref=""{typeName}""/> to object <see cref=""{primitiveType}""/>.
        /// </summary>
        /// <param name=""customPrimitive"">Custom primitive value.</param>
        public static implicit operator {primitiveType}({typeName} customPrimitive) => customPrimitive.Value;

        /// <inheritdoc />
        public override string ToString() => Value.ToString();

        /// <summary>
        /// Create new instance.
        /// </summary>
        /// <param name=""primitive"">Built-in language primitive value.</param>
        /// <returns>Custom primitive.</returns>
        public static {typeName} New({primitiveType} primitive) => new(primitive);
   }}
{(typeNamespace is null ? null : @"}
")}";
}
