namespace Generators;

[Generator]
public sealed class PrimitiveGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext generatorContext)
    {
        if (!Debugger.IsAttached)
        {
            Debugger.Launch();
        }

        generatorContext.RegisterPostInitializationOutput(t =>
            t.AddSource("PrimitiveAttribute.g.cs", SourceText.From(Attributes.AttributesDeclaration, Encoding.UTF8)));

        generatorContext.RegisterPostInitializationOutput(t =>
            t.AddSource("ILogic.g.cs", SourceText.From(Interfaces.LogicInterfaceDeclaration, Encoding.UTF8)));

        PrimitiveComparer comparer = PrimitiveComparer.Instance;

        IncrementalValuesProvider<PrimitiveToGenerate> pipeline = generatorContext.SyntaxProvider
            .CreateSyntaxProvider(
                FilterSyntaxNodes.NodePredicate,
                FilterSyntaxNodes.TargetFactory)
            .Where(t => t is not null)!
            .WithComparer(comparer)
            .Collect()
            .SelectMany((targets, _) => targets.Distinct(comparer));

        generatorContext.RegisterSourceOutput(pipeline, Execute);
    }

    private static void Execute(
        SourceProductionContext context,
        PrimitiveToGenerate primitive)
    {
        string? typeNamespace = primitive.Type.ContainingNamespace.IsGlobalNamespace
            ? null
            : primitive.Type.ContainingNamespace.ToString();

        string code = GenerateCode(primitive, typeNamespace);

        context.AddSource($"{primitive.Type.Name}.g", code);
    }

    private static string GenerateCode(PrimitiveToGenerate primitiveModel, string? typeNamespace)
    {
        bool isReferenceType =
            primitiveModel.Declaration.IsKind(SyntaxKind.ClassDeclaration)
            || primitiveModel.Declaration.IsKind(SyntaxKind.RecordDeclaration);

        string modifiers = string.Join(" ", primitiveModel.Declaration.Modifiers);

        return isReferenceType
            ? GenerateReferenceType(primitiveModel, typeNamespace, modifiers, primitiveModel.AttributePrimitiveName)
            : GenerateValueType(primitiveModel, typeNamespace, modifiers, primitiveModel.AttributePrimitiveName);
    }

    private static string GenerateValueType(
        PrimitiveToGenerate primitiveModel,
        string? typeNamespace,
        string modifiers,
        string primitiveType)
    {
        bool isRecordStruct = primitiveModel.Declaration.IsKind(SyntaxKind.RecordStructDeclaration);

        string keyword = isRecordStruct ? Keywords.RecordStruct : Keywords.Struct;

        string typeName = primitiveModel.Type.Name;

        return @$"// <auto-generated />

{(typeNamespace is null ? null : $@"namespace {typeNamespace}
{{")}
   /// <summary>
   /// Custom primitive.
   /// </summary>
   {modifiers} {keyword} {typeName}
   {{
        /// <summary>
        /// Primitive value.
        /// </summary>
        public {primitiveType} Value {{ get; }}

        /// <summary>
        /// Private ctor.
        /// </summary>
        /// <param name=""value"">Built-in language primitive value.</param>
        private {typeName}({primitiveType} value)
        {{
            Validate(value);
            Value = value;
        }}

        /// <summary>
        /// Leads from object <see cref=""{primitiveType}""/> to object <see cref=""{typeName}""/>. 
        /// </summary>
        /// <param name=""primitive"">Built-in language primitive value.</param>
        public static explicit operator {typeName}({primitiveType} primitive) => new(primitive);

        /// <summary>
        /// Leads from object <see cref=""{typeName}""/> to object <see cref=""{primitiveType}""/>.
        /// </summary>
        /// <param name=""customPrimitive"">Custom primitive value.</param>
        public static implicit operator {primitiveType}({typeName} customPrimitive) => customPrimitive.Value;

        public static bool operator ==({typeName} lhs, {typeName} rhs) => lhs.Equals(rhs);

        public static bool operator !=({typeName} lhs, {typeName} rhs) => !(lhs == rhs);

        /// <inheritdoc />
        public override string ToString() => Value.ToString();

        /// <summary>
        /// Create new instance.
        /// </summary>
        /// <param name=""primitive"">Built-in language primitive value.</param>
        /// <returns>Custom primitive.</returns>
        public static {typeName} New({primitiveType} primitive) => new(primitive);

        /// <inheritdoc />
        public bool Equals({typeName}? other) => Value == other?.Value;

        /// <inheritdoc />
        public override bool Equals(object? obj)
        {{
            if (obj is null)
            {{
                return false;
            }}

            if (ReferenceEquals(this, obj))
            {{
                return true;
            }}

            return obj.GetType() == GetType()
                   && Equals(({typeName})obj);
        }}

        /// <inheritdoc />
        public override int GetHashCode() => Value.GetHashCode();
   }}
{(typeNamespace is null ? null : @"}
")}";
    }

    private static string GenerateReadOnlyStruct()
    {
        throw new NotImplementedException();
    }

    private static string GenerateRecordStruct()
    {
        throw new NotImplementedException();
    }

    private static string GenerateStruct()
    {
        throw new NotImplementedException();
    }

    private static string GenerateReferenceType(
        PrimitiveToGenerate primitiveModel,
        string? typeNamespace,
        string modifiers,
        string primitiveType)
    {
        string keyword = primitiveModel.Declaration.Keyword.Text;

        string typeName = primitiveModel.Type.Name;

        return @$"// <auto-generated />

{(typeNamespace is null ? null : $@"namespace {typeNamespace}
{{")}
   /// <summary>
   /// Custom primitive.
   /// </summary>
   {modifiers} {keyword} {typeName}
   {{
        /// <summary>
        /// Primitive value.
        /// </summary>
        public {primitiveType} Value {{ get; }}

        /// <summary>
        /// Private ctor.
        /// </summary>
        /// <param name=""value"">Built-in language primitive value.</param>
        private {typeName}({primitiveType} value)
        {{
            Validate(value);
            Value = value;
        }}

        /// <summary>
        /// Leads from object <see cref=""{primitiveType}""/> to object <see cref=""{typeName}""/>. 
        /// </summary>
        /// <param name=""primitive"">Built-in language primitive value.</param>
        public static explicit operator {typeName}({primitiveType} primitive) => new(primitive);

        /// <summary>
        /// Leads from object <see cref=""{typeName}""/> to object <see cref=""{primitiveType}""/>.
        /// </summary>
        /// <param name=""customPrimitive"">Custom primitive value.</param>
        public static implicit operator {primitiveType}({typeName} customPrimitive) => customPrimitive.Value;

        public static bool operator ==({typeName} lhs, {typeName} rhs) => lhs.Equals(rhs);

        public static bool operator !=({typeName} lhs, {typeName} rhs) => !(lhs == rhs);

        /// <inheritdoc />
        public override string ToString() => Value.ToString();

        /// <summary>
        /// Create new instance.
        /// </summary>
        /// <param name=""primitive"">Built-in language primitive value.</param>
        /// <returns>Custom primitive.</returns>
        public static {typeName} New({primitiveType} primitive) => new(primitive);

        /// <inheritdoc />
        public bool Equals({typeName}? other) => Value == other?.Value;

        /// <inheritdoc />
        public override bool Equals(object? obj)
        {{
            if (obj is null)
            {{
                return false;
            }}

            if (ReferenceEquals(this, obj))
            {{
                return true;
            }}

            return obj.GetType() == GetType()
                   && Equals(({typeName})obj);
        }}

        /// <inheritdoc />
        public override int GetHashCode() => Value.GetHashCode();
   }}
{(typeNamespace is null ? null : @"}
")}";
    }

    private static string GenerateClass()
    {
        throw new NotImplementedException();
    }

    private static string GenerateRecord()
    {
        throw new NotImplementedException();
    }
}